"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const linereader_1 = require("./linereader");
class Indexer {
    constructor(stacksize) {
        this._stacksize = stacksize;
        this._stack = [];
        this._prefix = "";
    }
    index(filename, keyfunc) {
        this._stack.push({ start: 0, end: 0, children: {} });
        this._prefix = "";
        return new Promise((resolve, reject) => {
            const rs = fs.createReadStream(filename);
            const rl = new linereader_1.LineReader(rs);
            rl.on("line", (line) => {
                line.value = keyfunc(line.value);
                this.process(line);
            });
            rl.on("close", (bytes) => {
                resolve(this.finish(bytes) || { start: 0, end: 0, children: {} });
                rs.destroy();
            });
            rs.on("error", error => {
                reject(error);
                rs.destroy();
            });
        });
    }
    process(line) {
        if (!line.value.startsWith(this._prefix)) {
            this.exit(line);
        }
        if (line.value !== this._prefix) {
            this.enter(line);
        }
    }
    enter(line) {
        const value = line.value;
        while (this._prefix !== line.value &&
            this._stack.length < this._stacksize) {
            const key = value.slice(this._prefix.length)[0];
            const node = {
                start: line.offset,
                end: line.offset,
                children: {}
            };
            this._stack[this._stack.length - 1].children[key] = node;
            this._stack.push(node);
            this._prefix = this._prefix + key;
        }
    }
    exit(line) {
        while (!line.value.startsWith(this._prefix)) {
            this.pop(line.offset);
        }
    }
    finish(bytes) {
        var root = null;
        while (this._stack.length) {
            root = this.pop(bytes);
        }
        return root;
    }
    pop(offset) {
        this._stack[this._stack.length - 1].end = offset;
        this._prefix = this._prefix.slice(0, this._prefix.length - 1);
        return this._stack.pop() || null;
    }
}
class TextIndexer {
    constructor(filename, keyfunc, stacksize) {
        this._filename = filename;
        this._keyfunc = keyfunc;
        this._stacksize = stacksize;
        this._index = Promise.resolve({ start: 0, end: 0, children: {} });
    }
    index() {
        return this._index
            .catch(() => { })
            .then(_ => {
            this._index = new Indexer(this._stacksize).index(this._filename, this._keyfunc);
            return this._index;
        });
    }
    lookup(key) {
        return this._index.then(index => {
            for (let i = 0; i < key.length; ++i) {
                const ki = key[i];
                if (!index.children[ki]) {
                    return i == this._stacksize - 1 ? index : null;
                }
                index = index.children[ki];
            }
            return index;
        });
    }
}
exports.TextIndexer = TextIndexer;
//# sourceMappingURL=index.js.map